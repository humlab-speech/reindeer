% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/reindeer_sequence_ops_optimized.R
\name{scout}
\alias{scout}
\title{Optimized Sequence Operations with data.table}
\usage{
scout(
  .segments,
  steps_forward,
  count_from = "START",
  capture = 1,
  ignore_bundle_boundaries = FALSE,
  calculate_times = TRUE,
  times_from = NULL,
  .from = NULL,
  .quiet = TRUE,
  collect = TRUE
)
}
\arguments{
\item{.segments}{segment_list or lazy_segment_list object}

\item{steps_forward}{Integer; number of steps to move forward (positive) or backward (negative)}

\item{count_from}{Character; "START" or "END" of segment}

\item{capture}{Integer; number of consecutive items to capture (default 1)}

\item{ignore_bundle_boundaries}{Logical; whether to cross bundle boundaries}

\item{calculate_times}{Logical; whether to calculate start/end times}

\item{times_from}{Character; level to use for time calculation}

\item{.from}{corpus object (optional, for additional context)}

\item{.quiet}{Logical; suppress messages}

\item{collect}{Logical; force materialization (default TRUE)}
}
\value{
segment_list (or lazy_segment_list if collect=FALSE)
}
\description{
This module provides highly optimized implementations of sequential
query operations (scout, retreat) using data.table and supporting
lazy evaluation through SQL query building.
}
\section{Performance}{

\itemize{
\item Uses data.table for fast joins and filtering
\item Supports lazy evaluation via lazy_segment_list
\item 2-5x faster than emuR::requery_seq for large datasets
}
}

\examples{
\dontrun{
# Get next phoneme
next_phone <- scout(segments, steps_forward = 1)

# Get previous phoneme  
prev_phone <- scout(segments, steps_forward = -1)

# Get next 2 phonemes
next_two <- scout(segments, steps_forward = 1, capture = 2)

# Lazy version
lazy_next <- scout(segments, steps_forward = 1, collect = FALSE)
result <- collect(lazy_next)
}
}
\author{
reindeer package
Scout Forward in Sequence

Navigate forward through sequential items on the same level, optionally
capturing multiple items. Optimized implementation using data.table.
}
